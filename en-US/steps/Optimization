* bullet 1
* bullet 2

This optimization step is very crucial for reconciling any data accuracy and completeness; performance issues with the workload. There are no automated tools for post migration validation and optimization, but Tiger can provide scripts that aid in the detection of some of these tasks/scenarios (Tiger is also building some automation to query plan analysis starting in Potassium, that can be leveraged as part of this). Below are the recommend steps for Performance Tuning Patterns and Practices.

### Common Performance Scenarios

#### Sensitivity to parameter sniffing

* bullet 1
* bullet 2

* SQL Server compiles query plans on stored procedures by using sniffing the input parameters at the first compile, generating a parameterized and reusable plan, optimized for that input data distribution.
* Even if not stored procedures, most statements generating trivial plans will be parameterized.
* After a plan is first cached, any future execution maps to a previously cached plan.
* A potential problem arises when that first compilation may not have used the most common sets of parameters for the usual workload.
* For different parameters, the same execution plan becomes inefficient.

  ***Steps to resolve***

* Use the RECOMPILE hint
* With this a plan is calculated every time, adapted to each parameter value
* Rewrite the stored procedure to use the option (OPTIMIZE FOR(<input parameter> = <value>)) 
* Need to decide which value we want to use that suits most of the relevant workload, creating and maintaining one plan that becomes efficient for the parameterized value
* Rewrite the stored procedure using local variable inside the procedure
* Now the optimizer uses the density vector for estimations, resulting in the same plan regardless of the parameter value.
* Rewrite the stored procedure to use the option (OPTIMIZE FOR UNKNOWN)
* Same practical effect as using the local variable technique.
* Rewrite the query to use the hint 'DISABLE_PARAMETER_SNIFFING'.
* Same practical effect as using the local variable technique by totally disabling parameter sniffing, unless OPTION(RECOMPILE), WITH RECOMPILE or OPTIMIZE FOR value is used.
	

#### Missing indexes

* Wrong or missing indexes causes extra I/O, which leads to extra memory and CPU being wasted.
* Evidence of a poor indexing strategy or changes in workload profile. 
* Look for duplicate, redundant, rarely used and completely unused indexes.
* Special care with unused indexes with updates.

  ***Steps to resolve***
* Leverage the graphical execution plan for Missing Index references.
* Indexing suggestions generated by Database Engine Tuning Advisor.
* Missing Indexes from DMV or SQL Plans.
* Look for missing, duplicate, redundant, rarely used and completely unused indexes using scripts [here](https://blogs.msdn.microsoft.com/blogdoezequiel/2012/04/07/sql-swiss-army-knife-12-index-information-galore/)
 and those that may be hinted/hard-coded [here](https://blogs.msdn.microsoft.com/blogdoezequiel/2014/11/12/sql-swiss-army-knife-15-handling-duplicate-indexes/). 


#### Inability to use predicates to filter data

* SQL Server optimizer can only account for information that is known at compile time
* If a workload relies on predicates that can only be known at execution time, them the potential for a poor plan choice increases.
* For a better-quality plan, predicates must be SARGable, or Search Argumentable.
* Examples of non-SARGable:
	1. Implicit data conversions, like VARCHAR to NVARCHAR. Look for CONVERT_IMPLICIT warning. Converting from one type to another can also cause a loss of precision.
	2. Complex undetermined expressions such as “WHERE UnitPrice + 1 < 3.975”, but not “WHERE UnitPrice < 320 * 200 * 32” *
	3. Expressions using functions, such as “WHERE ABS(ProductID) = 771” or “WHERE UPPER(LastName) = ‘LOPES’”
	4. Strings with a leading wildcard character, such as “WHERE LastName LIKE ‘%Lopes’”
	
  ***Steps to resolve***
* Always declare variables as target data type. 
	1. This is a matter of comparing code (sprocs, functions, etc) with system tables that hold information on data types for underlying tables used.
* Change the data type on the table for the same purpose.
* Carefully reason about usefulness of:
  1. Functions being used as predicates.
  2. Wildcard searches.
  3.  Complex expressions based on columnar data – evaluate persisted learn columns.
  4. All of the above can be done programmatically.

#### Use of Table Valued Functions (Multi-valued vs Inline)

* Return a table data type that can be an alternative to views. 
* While views are limited to a single SELECT statement, user-defined functions can contain additional statements that allow more logic than is possible in views.
* The caveat? Since the table is not populated at compile time, the optimizer relies on heuristics, and not actual statistics.
    * We can add indexes to the base table(s) but it is not going to help much. 
    * SQL Server assumes 1 row will be returned from a TVF (with SQL Server 2014 that becomes 100).

#### SQL Server Heuristics
Learn more about [SQL Server heuristics Part 1](https://blogs.msdn.microsoft.com/blogdoezequiel/2012/11/30/table-variables-and-row-estimations-part-1/) and [Part 2](https://blogs.msdn.microsoft.com/blogdoezequiel/2012/12/09/table-variables-and-row-estimations-part-2/).

  ***Steps to resolve***

If the TVF is single statement only, convert to inline TVF.
	“CREATE FUNCTION dbo.tfnGetRecentAddress(@ID int)
	RETURNS @tblAddress TABLE
	([Address] VARCHAR(60) NOT NULL)
	AS
	BEGIN
		INSERT INTO @tblAddress ([Address])
		SELECT TOP 1 [AddressLine1]
		FROM [Person].[Address]
		WHERE  AddressID = @ID
		ORDER BY [ModifiedDate] DESC
	RETURN
	END”

	TO 

	“CREATE FUNCTION dbo.tfnGetRecentAddress_inline(@ID int)
	RETURNS TABLE
	AS
	RETURN (
		SELECT TOP 1 [AddressLine1] AS [Address]
		FROM [Person].[Address]
		WHERE  AddressID = @ID
		ORDER BY [ModifiedDate] DESC
	)”

If more complex, consider using intermediate results stored in in-memory tables or temporary tables.

### Performance Tuning Tools

It is difficult to determine when, why and how the plan changed. Fixing Plan Choice Regressions can be hard. Here are a few steps that can help diagnose plan regressions. 

**First You must find the “Slow” Query** – How do you know if it is slow? You can find the slowest query, but how do you know how it typically runs. Therefore, we usually recommend having a baseline of the critical applications. 

**Figuring out Why it is slow isn’t Easy**
* You do not have the data to fix the problem. SQL Server does not have the internal data structures well suited for solving these types of problems. 
* We typically try to use plan cache DMVs to try and solve these issues, but the plan cache is also not well suited for performance troubleshooting. The reasons is that the plan cache does not track all of the queries. The plan cache is meant to speed up and avoid compilations. The plans I most frequently need are cached so I do not need to compile them. So, if I have a query with the WITH RECOMPILE clause it will never get cached and will always compile on execution. 
* The Plan cache is also a structure that shares memory with everything else in SQL Server. So, when there is memory pressure it will ask the plan cache to downsize and will therefore evict some things. 
* In summary, it only has the latest plan for the query and it is not persistent. The Plan Cache does not record everything. The Plan Cache also only has the statistics for performance since the last restart of the system.

**Long time to detect the issue (Time to Detect - TTD)**
* Identify which query is slow and why is it slow?
* What was the previous plan? – It can be very tedious to find the plan, and if you know it, it can be difficult to apply a plan forcing hint to address the problem.

**Long time to mitigate (Time to Mitigate - TTM)**
* Often takes a long time to even detect that there is a plan problem.
* Only the latest plan is stored in the cache.
* Need to catch both the good and the bad plan to troubleshoot.
* Reboot or memory pressure causes diagnostic data to be lost.
* Can I modify the query to hint it? How to use plan guide?
