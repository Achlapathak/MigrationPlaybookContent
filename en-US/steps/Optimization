#### Inability to use predicates to filter data

* SQL Server optimizer can only account for information that is known at compile time.
* If a workload relies on predicates that can only be known at execution time, them the potential for a poor plan choice increases.
* For a better-quality plan, predicates must be SARGable, or Search Argumentable.
* Examples of non-SARGable:
  1. Implicit data conversions, like VARCHAR to NVARCHAR. Look for CONVERT_IMPLICIT warning. Converting from one type to another can also cause a loss of precision.
  2. Complex undetermined expressions such as “WHERE UnitPrice + 1 < 3.975”, but not “WHERE UnitPrice < 320 * 200 * 32” *
  3. Expressions using functions, such as “WHERE ABS(ProductID) = 771” or “WHERE UPPER(LastName) = ‘LOPES’”
  4. Strings with a leading wildcard character, such as “WHERE LastName LIKE ‘%Lopes’”
  
***Steps to resolve***
* Always declare variables as target data type.
  1. This is a matter of comparing code (sprocs, functions, etc) with system tables that hold information on data types for underlying tables used.
* Change the data type on the table for the same purpose.
* Carefully reason about usefulness of:
  1. Functions being used as predicates.
  2. Wildcard searches.
  3. Complex expressions based on columnar data – evaluate persisted learn columns.
  4. All of the above can be done programmatically.
  
#### Use of Table Valued Functions (Multi-valued vs Inline)

* Return a table data type that can be an alternative to views.
* While views are limited to a single SELECT statement, user-defined functions can contain additional statements that allow more logic than is possible in views.
* The caveat? Since the table is not populated at compile time, the optimizer relies on heuristics, and not actual statistics.
    * We can add indexes to the base table(s) but it is not going to help much.
    * SQL Server assumes 1 row will be returned from a TVF (with SQL Server 2014 that becomes 100).

#### SQL Server Heuristics
Learn more about [SQL Server heuristics Part 1](https://blogs.msdn.microsoft.com/blogdoezequiel/2012/11/30/table-variables-and-row-estimations-part-1/) and [Part 2](https://blogs.msdn.microsoft.com/blogdoezequiel/2012/12/09/table-variables-and-row-estimations-part-2/).

***Steps to resolve***

If the TVF is single statement only, convert to inline TVF.
	“CREATE FUNCTION dbo.tfnGetRecentAddress(@ID int)
	RETURNS @tblAddress TABLE
	([Address] VARCHAR(60) NOT NULL)
	AS
	BEGIN
		INSERT INTO @tblAddress ([Address])
		SELECT TOP 1 [AddressLine1]
		FROM [Person].[Address]
		WHERE  AddressID = @ID
		ORDER BY [ModifiedDate] DESC
	RETURN
	END”

	TO

	“CREATE FUNCTION dbo.tfnGetRecentAddress_inline(@ID int)
	RETURNS TABLE
	AS
	RETURN (
		SELECT TOP 1 [AddressLine1] AS [Address]
		FROM [Person].[Address]
		WHERE  AddressID = @ID
		ORDER BY [ModifiedDate] DESC
	)”

If more complex, consider using intermediate results stored in in-memory tables or temporary tables.

### Performance Tuning Tools

It is difficult to determine when, why and how the plan changed. Fixing Plan Choice Regressions can be hard. Here are a few steps that can help diagnose plan regressions.

**First You must find the “Slow” Query** – How do you know if it is slow? You can find the slowest query, but how do you know how it typically runs. Therefore, we usually recommend having a baseline of the critical applications.

**Figuring out Why it is slow isn’t Easy**
* You do not have the data to fix the problem. SQL Server does not have the internal data structures well suited for solving these types of problems.
* We typically try to use plan cache DMVs to try and solve these issues, but the plan cache is also not well suited for performance troubleshooting. The reasons is that the plan cache does not track all of the queries. The plan cache is meant to speed up and avoid compilations. The plans I most frequently need are cached so I do not need to compile them. So, if I have a query with the WITH RECOMPILE clause it will never get cached and will always compile on execution.
* The Plan cache is also a structure that shares memory with everything else in SQL Server. So, when there is memory pressure it will ask the plan cache to downsize and will therefore evict some things.
* In summary, it only has the latest plan for the query and it is not persistent. The Plan Cache does not record everything. The Plan Cache also only has the statistics for performance since the last restart of the system.

**Long time to detect the issue (Time to Detect - TTD)**
* Identify which query is slow and why is it slow?
* What was the previous plan? – It can be very tedious to find the plan, and if you know it, it can be difficult to apply a plan forcing hint to address the problem.

**Long time to mitigate (Time to Mitigate - TTM)**
* Often takes a long time to even detect that there is a plan problem.
* Only the latest plan is stored in the cache.
* Need to catch both the good and the bad plan to troubleshoot.
* Reboot or memory pressure causes diagnostic data to be lost.
* Can I modify the query to hint it? How to use plan guide?
